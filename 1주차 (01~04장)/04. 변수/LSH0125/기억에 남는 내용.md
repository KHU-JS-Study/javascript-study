# ✏️ 기억에 남는 내용

- **변수(Variable)**
  + 하나의 값을 저장하기 이해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름, 값의 위치를 가리키는 상징적인 이름 (36p)
  + 메모리 공간의 주소로 치환되어 실행되므로, 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 안전하게 값에 접근할 수 있다. (37p)
  + 여러 개의 값을 저장하려면 여러 개의 변수를 사용해야 하지만, **배열이나 객체와 같은 자료구조**를 사용하면 여러 개의 값을 그룹화하여 하나의 값처럼 사용할 수 있다. (37p)

- **식별자 (Identifier)**
  + 어떤 값을 구별해서 식별할 수 있는 고유한 이름 (변수, 함수, 클래스 등의 이름) (38p)
  + 값이 아니라 메모리 주소를 기억하고 있다. (값을 저장 x 접근 가능 o) (39p)
  + 모든 식별자는 반드시 선언이 필요하다. (42p)

- **식별자 네이밍 규칙**
  + 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함 가능하며, 숫자로 시작하는 것은 허용하지 않고, 예약어는 식별자로 사용할 수 없다. 
  + 좋은 변수 이름 : 주석이 필요 없을 정도로 존재 목적을 쉽게 이해할 수 있도록 명확하게 표현해야한다.  
  + **네이밍 컨벤션(naming convention)** :
  하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙
    * 카멜 케이스 (camelCase)
    * 스네이크 케이스 (snake_case)
    * 파스칼 케이스 (PascalCase)
    * 헝가리언 케이스 (typeHungarianCase)


- **📑 용어 정리**
  + **참조(Reference)** : 변수에 저장된 값을 읽어 들이는 것 (38p)
  
  + **키워드(Keyword)** : 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 **일종의 명령어** (40p)
  
  + **ReferenceError(참조 에러)** : 선언하지 않은 식별자에 접근하면 발생하는 에러 (참조하려 했지만 찾을 수 없음) (42p)

  + **변수 선언(Variable Declaration)** 
    * 변수를 생성하는 것 (var, let,  const 키워드 사용) (39p)
    * 선언 동시에 **undefined**라는 값이 암묵적으로 할당되어 **초기화**된다. (41p)
    * 실행되는 시점은 런타임(runtime, 소스코드가 한 줄씩 순차적으로 실행되는 시점)이 아니라 그 이전 단계이다. (변수 호이스팅) (42p)

  + **할당(Assignment)** (대입,저장) : 
    * 변수의 값을 저장하는 것 (38p)
    * 할당 연산자 = 을 사용하여 우변의 값을 좌변의 변수에 할당한다. (43p)
    * 변수 선언과 달리 실행 시점은 런타임이다. (43p)

  + **재할당** :
    * 이미 값이 할당되어 있는 변수에 저장된 값을 버리고 새로운 값을 저장하는 것 
    * 재할당할 수 없어서 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)라고 한다. (45p)
    * 같은 메모리 공간에 새로운 값을 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 새로운 값을 저장하는 것이다. (46p)
  
  + **호이스팅(hoisting)** : 
    * 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
    * var, let, const, function, function*, class 키워드로 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. (43p)
