# ✏️ 기억에 남는 내용
- **빌트인 생성자 함수** 
  + new 연산자와 함께 `Object` 생성자 함수를 호출하여 빈 객체를 생성한 뒤, 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있다.
  ```javascript
  const person = new Object();  
  ```
  + 자바스크립트는 `Object` 생성자 함수 이외에도 `String`, `Number`, `Boolean`, `Function`, `Array`, `Date`, `RegExp`, `Promise` 등의 빌트인 생성자 함수를 제공한다.
  + new 연산자와 함께 호출하여 객체를 생성하는 함수를 생성자 함수라고 하고, 이 때 생성된 객체를 **인스턴스**라 한다.

- **객체 리터럴**과 **생성자 함수** 
  + **객체 리터럴에 의한 객체 생성** 방식은 직관적이고 간편하지만 동일한 프로퍼티를 갖는 여러 개의 객체를 생성해야 하는 경우에는 매우 번거롭고 비효율적이다.
  + 따라서 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하는 생성자 함수를 이용하는 편이 낫다. 생성자 함수는 인스턴스를 생성하고(필수), 생생된 인스턴스를 초기화(옵션)한다.

- **생성자 함수의 인스턴스 생성 과정**
  + 자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 초기화한 뒤 반환한다. 명시적으로 return 문을 적지 않아도 인스턴스가 반환되는 것이다.

  + 명시적으로 return 문을 작성한다면 원시 값은 무시되고 객체는 인스턴스 대신 명시한 객체가 반환된다. this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손하므로 생성자 함수 내부애서 return 문을 반드시 생략해야 한다!
  + `this`
    * 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수다. this가 가리키는 값, this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.
    * 일반 함수로서 호출할 경우 전역 객체, 메서드로서 호출할 경우 메서드를 호출한 객체, 생성자 함수로서 호출할 경우 생성자 함수가 생성할 인스턴스를 가리킨다.
```javascript
function Circle(radius){
    // 1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다.

    // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
    this.radius = radius;
    this.getDiameter = function () {
        return 2 * this.radius;
    };
    // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
} 
// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.
const circle = new Circle(1);
```

- **내부 메서드 [[Call]]과 [[Construct]], 그리고 constructor와 non-constructor**
  + 함수 객체는 함수로서 동작하기 위해 함수 객체만을 위한 내부 슬롯과[[Call]], [[Construct]] 같은 내부 메서드를 추가로 가지고 있다.
  + 함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다. 
  + 모든 함수 객체는 내부 메서드 [[Call]]을 갖지만 (callable) 모두 내부 메서드 [[Construct]]를 갖는 것은 아니다. 내부 메서드 [[Construct]]를 갖는 함수 객체를 ***constructor***, 내부 메서드 [[Construct]]를 갖지 않는 함수 객체를 ***non-constructor*** 라고 한다.
  + 함수 선언문과 함수 표현식으로 정의된 함수만이 constructor이고 화살표 함수와 메서드 축약 표현으로 정의된 함수는 non-constructor이다.

- **일반 함수**와 **생성자 함수**
  + 일반 함수와 동일한 방법으로 정의하고, new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.

  + 일반 함수와 생성자 함수는 특별한 형식적 차이가 없기 때문에 생성자 함수는 일반적으로 첫 문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다.

  + 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 발생할 수 있기에 생성자 함수가 new 연산자 없이 호출되는 것을 방지해야한다.
    * 함수 내부에서 `new.target`을 사용하면 생성자 함수로서 호출되었는지, 일반 함수로서 호출되었는지 알 수 있다. 이를 통해 재귀 호출을 통해 생성자 함수로 호출할 수 있다.
    * **스포크 세이프 생성자 패턴**을 사용하여 실수를 방지할 수도 있다. (예제 코드 참고)
      
